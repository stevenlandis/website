<!DOCTYPE html><html lang="en"><head><title>bld2</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image" href="../rec/favicon/16x16.png" sizes="16x16"/><link rel="icon" type="image" href="../rec/favicon/32x32.png" sizes="32x32"/><link rel="icon" type="image" href="../rec/favicon/96x96.png" sizes="96x96"/><link rel="stylesheet" href="../rec/styles.css"/><link rel="stylesheet" href="../rec/highlight.css"/></head><body><div class="main"><div class="title">bld2</div><div class="navbar"><span><a href="..//">Home</a></span><span><a style="margin-left:3em;" href="../resume">Resume</a></span><span><a style="margin-left:3em;" href="../postsList">Posts</a></span><span><a style="margin-left:3em;" href="../fractalGenerator/fractal">Fractal Generator</a></span></div><h2>Motivation</h2>
<p>This website is a static website that I built from scratch. That means I had to build my own static website generator which led me to create a project building library for incremental builds called bld (short for build).</p>
<p>However, I wasn't pleased with how my project builder was scaling and I didn't like the complexity of adding new rules. The real benefit of bld was its wrapper functions for common project building actions rather than its syntax for indicating project structure. The <code class="code codespan">File</code> and <code class="code codespan">Dir</code> objects made it really easy to create complex file structures in little code and the <code class="code codespan">bld.call</code> function made it easy to call building commands.</p>
<p>Some of the features such as directory merge/remove actions weren't as useful as I originally thought.</p>
<p>In summary, bld had some unnecessary features and the code wasn't easy to read.</p>
<h2>bld2</h2>
<p>The original bld takes a functional approach to creating projects: the programmer specifies the dependency structure for their project and bld figures out how to accomplish that structure.</p>
<p>I ended up making bld2 more imperative where the programmer indicates <em>how</em> to build the project. And it all comes down to one function:</p>
<pre class="code codeblock"><code>shouldUpdate(sourceFiles, resultFiles)

sourceFiles: array of File objects or paths
resultFIles: array of File objects or paths</code></pre><p>Let's say I have <code class="code codespan">main.c</code> and I want to compile it into the executable <code class="code codespan">main</code> using <code class="code codespan">shouldUpdate</code>:</p>
<pre class="code codeblock"><code><span></span><span class="k">if</span> <span class="n">shouldUpdate</span><span class="p">([</span><span class="s1">&#39;main.c&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">]):</span>
    <span class="n">bld</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;gcc main.c -o main&#39;</span><span class="p">)</span>
</code></pre><p>Rather than creating complex subclassed <code class="code codespan">Rule</code> objects for each build step, this syntax clearly shows <em>how</em> bld2 executes the program and saves the programmer a few lines of code.</p>
<p>However, there are a few features that can't be implemented because of this change:</p>
<ul>
<li>Multithreading: bld2 can no longer create a task queue and distribute building steps on multiple processors because it can't reason about dependency. This feature wasn't implemented in bld, but that feature is no longer possible.</li>
<li>Automatic clean function: bld2 can no longer automatically remove created files. However, now that I think about it, programmers can just store a list of all created files and remove the files from that list on clean. Having a list of created files would also be useful for obsolete files. I like this better.</li>
</ul>
<p>And that's the thing. The more I think about functionality that gets lost in the transition from imperative to functional, the more solutions I find. I guess it's easier to build a functional system atop an imperative system than the other way around.</p>
<p>The best guarantee for a partial-building system is the output is identical to if the project was build from scratch for the first time. It is very functional because the programmer just describes what they want the output to look like and not how to achieve that output. What, not how.</p>
<p>One common issue with build systems is leftover files. For example, if you compile</p>
<pre class="code codeblock"><code>gcc main.c -o main</code></pre><p>once, you have <code class="code codespan">main</code> in your directory. However, if you want to change the executable's name to <code class="code codespan">myExecutable</code>, you would simply run</p>
<pre class="code codeblock"><code>gcc main.c -o myExecutable</code></pre><p>The issue is that your directory still has the leftover <code class="code codespan">main</code> executable which would not happen if the programmer built the project from scratch.</p>
<p>The easiest way to fix this issue is for <code class="code codespan">bld</code> to keep track of which files it has currently written, called <code class="code codespan">currentFiles</code>. When the build script runs, <code class="code codespan">bld</code> can keep track of all written files by listening to calls to <code class="code codespan">shouldUpdate</code>. This creates another set of files called <code class="code codespan">nextFiles</code>. All files in <code class="code codespan">currentFiles</code> that are not in <code class="code codespan">nextFiles</code> should be deleted.</p>
<h3>Example</h3>
<p>Initial directory:</p>
<pre class="code codeblock"><code>testDir
--build.py
--main.c</code></pre><p>Initial <code class="code codespan">build.py</code>:</p>
<pre class="code codeblock"><code><span></span><span class="k">if</span> <span class="n">shouldUpdate</span><span class="p">(</span><span class="s1">&#39;main.c&#39;</span><span class="p">,</span> <span class="s1">&#39;main&#39;</span><span class="p">):</span>
    <span class="n">bld</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;gcc main.c -o main&#39;</span><span class="p">)</span>
</code></pre><p>Directory after building:</p>
<pre class="code codeblock"><code>testDir
--build.py
--main.c
--main
--currentFiles</code></pre><p>And current files is a simply the following text file:</p>
<pre class="code codeblock"><code>main</code></pre><p>You then change <code class="code codespan">build.py</code> to the following:</p>
<pre class="code codeblock"><code><span></span><span class="k">if</span> <span class="n">shouldUpdate</span><span class="p">(</span><span class="s1">&#39;main.c&#39;</span><span class="p">,</span> <span class="s1">&#39;main&#39;</span><span class="p">):</span>
    <span class="n">bld</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;gcc main.c -o myExecutable&#39;</span><span class="p">)</span>
</code></pre><p>During the build, <code class="code codespan">currentFiles</code> is <code class="code codespan">[main]</code> and <code class="code codespan">nextFiles</code> is <code class="code codespan">[myExecutable]</code> which means bld deletes <code class="code codespan">main</code>.</p>
<p>Directory after building the second time:</p>
<pre class="code codeblock"><code>testDir
--build.py
--main.c
--myExecutable
--currentFiles</code></pre><p>And currentFiles is now the following text file:</p>
<pre class="code codeblock"><code>myExecutable</code></pre><p>A nice side effect of keeping a list of current files is that clean operations can be done automatically. Cleaning this directory means removing all non-essential files which removes all files in currentFiles and then removes currentFiles.</p>
<h2>What about directories?</h2>
<p>The one thing I overlooked in that example is directories. The easiest way to handle them is to keep track of all directories that had files removed from them. At the very end of the build process, the script checks those directories to see if any are empty and repeats the process until all directories have at least one thing in them. This is a similar approach to Github which doesn't support empty directories and instead focuses only on files which makes sense for projects because files are the only source of truth in a project. There is never a situation where project information is stored in a directory. As such, empty directories probably shouldn't exist.</p>
<p>But what is someone wants directories to exist? There may be a way to tell bld to keep track of directories and not delete some empty directories.</p>
</div></body></html>