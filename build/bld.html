<!DOCTYPE html><html><head><title>bld: Replacing Make</title><meta charset="UTF-8"><link rel="icon" type="image" href="./rec/favicon/16x16.png" sizes="16x16"/><link rel="icon" type="image" href="./rec/favicon/32x32.png" sizes="32x32"/><link rel="icon" type="image" href="./rec/favicon/96x96.png" sizes="96x96"/><link rel="stylesheet" href="./rec/styles.css"/><link rel="stylesheet" href="./rec/highlight/styles/xcode.css"/></head><body><div class="main"><div class="title">bld: Replacing Make</div><div class="navbar"><span><a href="index.html">Home</a></span><span><a style="margin-left:3em;" href="bld.html">bld.py</a></span><span><a style="margin-left:3em;" href="dragonCurve.html">Dragon Curve</a></span><span><a style="margin-left:3em;" href="siteElements.html">Site Elements</a></span><span><a style="margin-left:3em;" href="software.html">Software</a></span><span><a style="margin-left:3em;" href="scope.html">Scope</a></span></div><h1>Make is amazing</h1>
<p>Seriously. Make lets you build files incrementally while expressing complex build rules with an efficient syntax. It also lets you define custom commonly-used commands for a project which makes building and cleaning much easier.</p>
<p>The only downside is that Make is not a complete scripting language. I'm a pretty lazy person, so it was hard for me to learn the syntax of advanced rules and I ran into a few cases where I wanted to build my project in a way that Make didn't allow.</p>
<p>This is my motivation for bld. I want it to be a library that makes it easy to write files to build a project in python. Python is a great scripting languages with lots of libraries and it has a very clear syntax which makes it ideal for connecting different commands together into a build system.</p>
<h1>The Test</h1>
<p>To test how well my building library works, I made a static website generator and tested how easy it was to implement building features. If you are reading this website, then the test worked!</p>
<h2>Goals</h2>
<ul>
<li>Write a <code>build.py</code> file that creates a website.</li>
<li>Get incremental builds to work.</li>
<li>Get live building to work.</li>
</ul>
<p>I'm currently able to build a website, but incremental builds don't work. It turns out that python files can import other python files which means the incremental builder needs to read files to find dependencies. This should be a simple regex to extract imported files but it will make the builder much slower because it has to read through a lot of python files.</p>
<p>There are three ways around this:</p>
<ol>
<li>
<p>Get the build file to generate a static 'plan' for building the current project. It will be expensive to make this plan but running the plan is cheap. This assumes that most file changes only involve changing files and not creating new files or changing imports. I also have to re-generate the plan manually.</p>
</li>
<li>
<p>Get live building to work. This is the best solution but I really don't want to deal with watching a file. Yet. It is an eventual goal and will make my life a lot easier but it is a complex addition to this library and I need to think about how it will work.</p>
</li>
<li>
<p>Each file has a 'import' file in a temp directory that stores it's imports. This seems like a good neutral option because it makes it possible to do make-style incremental builds and keeps the expense of each run low. It does add a little more memory to the project.</p>
</li>
</ol>
<h1>The Building Blocks: Navigating the File System</h1>
<p>A key part of writing a build system is finding the files to build. For this website, I have a folder <code>pages/</code> with a bunch of files that define a page. Some pages that need custom control are a python file and other pages, such as this one, are a single markdown file with some meta-data.</p>
<p>This means bld.py has to recursively look through the contents of <code>pages/</code>. When it finds a python file, it runs that python file and saves the resulting string as an html file. When it finds a markdown file, it parses that file as markdown, highlights the corresponding code sections and saves that as html.</p>
<h2>Virtual And Disk Files and Directories</h2>
<p>This library provides all that functionality using two base objects, <code>DiskDir / DiskFile</code> and <code>VirDir / VirFile</code>. Disk objects are files and directories that actually exist on the disk and Vir objects are virtual files and directories that will be built (placed) during the build process. </p>
<p>These disk and virtual file objects make it easier to navigate and manipulate files and directories.</p>
<p>It all starts with getting the <code>pages/</code> directory:</p>
<div class="code"><pre><code>pageDir = bld.DiskDir(<span class="hljs-string">'src/pages'</span>)
</code></pre></div>

<p>The output will be stored in the <code>build/</code> directory and this is represented as a virtual directory that will be populated with files during the build process:</p>
<div class="code"><pre><code>buildDir = bld.VirDir(<span class="hljs-string">'build'</span>)
</code></pre></div>

<p>At this point, if I wanted to write <code>'Hello World'</code> to <code>build\test.txt</code>, I could use the following code:</p>
<div class="code"><pre><code>text = <span class="hljs-string">'Hello World'</span>

<span class="hljs-comment"># testFile is a VirFile</span>
testFile = buildDir.getFile(<span class="hljs-string">'test.txt'</span>)

<span class="hljs-comment"># place the output directory</span>
buildDir.place(<span class="hljs-string">'.'</span>)

<span class="hljs-comment"># write the file</span>
testFile.write(text)
</code></pre></div>

<p>I could then use this structure to build my whole project and I would be done. However, I only want to build the bare minimum number of files each time and I don't want to re-build <code>test.txt</code> if its contents don't change.</p>
<h2>Rules</h2>
<p>This is where rules come in. <code>Rule</code> is a class that can be sub-classed to create custom rules for building files. A rule has three parts:</p>
<ol>
<li>Input files</li>
<li>Output files</li>
<li>Some function to build the output files from input files</li>
</ol>
<p>Because a rule declares which files it depends on before running, <code>bld</code> checks the write time of the input files before running each rule which means <strong>each rule runs only when it needs to run</strong>.</p>
<p>In the previous example, I could replace the code with a rule for writing <code>'Hello World'</code> with a rule:</p>
<div class="code"><pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldRule</span><span class="hljs-params">(bld.Rule)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, outFile)</span>:</span>
        self.init()

        <span class="hljs-comment"># add single input file</span>
        self.addOut(outFile)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># print some text so we can see if the rule runs</span>
        print(<span class="hljs-string">f'Writing HelloWorld to <span class="hljs-subst">{self.outputs[<span class="hljs-number">0</span>].name}</span>'</span>)

        text = <span class="hljs-string">'Hello World'</span>
        self.outputs[<span class="hljs-number">0</span>].write(text)
</code></pre></div>

<p>And call it like:</p>
<div class="code"><pre><code>buildDir = bld.VirDir(<span class="hljs-string">'build'</span>)
testFile = buildDir.getFile(<span class="hljs-string">'test.txt'</span>)
HelloWorldRule(testFile)

buildDir.build(<span class="hljs-string">'.'</span>) <span class="hljs-comment"># automatically runs HelloWorldRule the first time</span>
</code></pre></div>

<p>When I start out, my file structure looks like this:</p>
<div class="code"><pre><code>./
    build.py
</code></pre></div>

<p>I then run <code>build</code> for the first time</p>
<div class="code"><pre><code>&gt;&gt;&gt; build
Writing HelloWorld to test.txt
&gt;&gt;&gt;
</code></pre></div>

<p>Then, my file structure looks like this:</p>
<div class="code"><pre><code>./
    build.py
    build/
        test.txt
</code></pre></div>

<p>It even made the folder <code>build/</code> so <code>text.txt</code> has a place to live!</p>
<p>When I run <code>build</code> again, the real magic happens:</p>
<div class="code"><pre><code>&gt;&gt;&gt; build
&gt;&gt;&gt;
</code></pre></div>

<p>Nothing! That's right, <code>Rule</code> automatically detects that <code>test.txt</code> already exists and doesn't run the rule again.</p>
<h2>Rule Inputs</h2>
<p>That's a cool example, but what if I want a file to depend on another file? This is where the input part of rules comes into play.</p>
<p>The simplest rule that takes another file as input is the copy rule which is included in <code>bld</code>, but I'll make a copy here:</p>
<div class="code"><pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyRule</span><span class="hljs-params">(bld.Rule)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, inFile, outFile)</span>:</span>
        self.init()
        self.addIn(inFile)
        self.addOut(outFile)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>
        [inFile] = self.inputs
        [outFile] = self.outputs
        outFile.write(inFile.read())
</code></pre></div>

<p>Yep, it's really that simple. I can use this rule to build the project as follows:</p>
<div class="code"><pre><code>Before:
./
    copyMe.txt

After:
./
    copyMe.txt
    copiedMe.txt
</code></pre></div>

<p>And the <code>build.py</code> file:</p>
<div class="code"><pre><code>copyMe = bld.DiskFile(<span class="hljs-string">'copyMe.txt'</span>)
copiedMe = bld.VirFile(<span class="hljs-string">'copiedMe.txt'</span>)
CopyRule(copyMe, copiedMe)

<span class="hljs-comment"># run the rule</span>
copiedMe.build(<span class="hljs-string">'.'</span>)
</code></pre></div></div></body></html>