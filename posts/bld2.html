<!doctype html><html><head><meta charset="UTF-8"><meta charset="UTF-8"><meta name="viewport" content="width=device-width" initial-scale="1.0"><link rel="icon" type="image" href="/favicon/16x16.png" sizes="16x16"><link rel="icon" type="image" href="/favicon/32x32.png" sizes="32x32"><link rel="icon" type="image" href="/favicon/96x96.png" sizes="96x96"><link rel="stylesheet" href="/css/styles.css"><link rel="stylesheet" href="/css/highlight.css"><title>bld2</title></head><body><div class="title">bld2</div><div class="main"><div class="navbar"><span><a href="/">Home</a></span><span><a style="margin-left:3em;" href="/resume">Resume</a></span><span><a style="margin-left:3em;" href="/posts/list">Posts</a></span><span><a style="margin-left:3em;" href="/fractal">Fractal Generator</a></span><span><a style="margin-left:3em;" href="/webapp/index">Webapp</a></span></div><h2>Motivation</h2><p>This website is a static website that I built from scratch. That means I had to build my own static website generator which led me to create a project building library for incremental builds called bld (short for build).</p><p>However, I wasn't pleased with how my project builder was scaling and I didn't like the complexity of adding new rules. The real benefit of bld was its wrapper functions for common project building actions rather than its syntax for indicating project structure. The <code>File</code> and <code>Dir</code> objects made it really easy to create complex file structures in little code and the <code>bld.call</code> function made it easy to call building commands.</p><p>Some of the features such as directory merge/remove actions weren't as useful as I originally thought.</p><p>In summary, bld had some unnecessary features and the code wasn't easy to read.</p><h2>bld2</h2><p>The original bld takes a functional approach to creating projects: the programmer specifies the dependency structure for their project and bld figures out how to accomplish that structure.</p><p>I ended up making bld2 more imperative where the programmer indicates <em>how</em> to build the project. And it all comes down to one function:</p><div class="highlight"><pre><span></span>shouldUpdate(sourceFiles, resultFiles)

sourceFiles: array of File objects or paths
resultFIles: array of File objects or paths
</pre></div><p>Let's say I have <code>main.c</code> and I want to compile it into the executable <code>main</code> using <code>shouldUpdate</code>:</p><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">shouldUpdate</span><span class="p">([</span><span class="s1">&#x27;main.c&#x27;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#x27;main&#x27;</span><span class="p">]):</span>
    <span class="n">bld</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#x27;gcc main.c -o main&#x27;</span><span class="p">)</span>
</pre></div><p>Rather than creating complex subclassed <code>Rule</code> objects for each build step, this syntax clearly shows <em>how</em> bld2 executes the program and saves the programmer a few lines of code.</p><p>However, there are a few features that can't be implemented because of this change:</p><ul><li>Multithreading: bld2 can no longer create a task queue and distribute building steps on multiple processors because it can't reason about dependency. This feature wasn't implemented in bld, but that feature is no longer possible.</li><li>Automatic clean function: bld2 can no longer automatically remove created files. However, now that I think about it, programmers can just store a list of all created files and remove the files from that list on clean. Having a list of created files would also be useful for obsolete files. I like this better.</li></ul><p>And that's the thing. The more I think about functionality that gets lost in the transition from imperative to functional, the more solutions I find. I guess it's easier to build a functional system atop an imperative system than the other way around.</p><p>The best guarantee for a partial-building system is the output is identical to if the project was build from scratch for the first time. It is very functional because the programmer just describes what they want the output to look like and not how to achieve that output. What, not how.</p><p>One common issue with build systems is leftover files. For example, if you compile</p><div class="highlight"><pre><span></span>gcc main.c -o main
</pre></div><p>once, you have <code>main</code> in your directory. However, if you want to change the executable's name to <code>myExecutable</code>, you would simply run</p><div class="highlight"><pre><span></span>gcc main.c -o myExecutable
</pre></div><p>The issue is that your directory still has the leftover <code>main</code> executable which would not happen if the programmer built the project from scratch.</p><p>The easiest way to fix this issue is for <code>bld</code> to keep track of which files it has currently written, called <code>currentFiles</code>. When the build script runs, <code>bld</code> can keep track of all written files by listening to calls to <code>shouldUpdate</code>. This creates another set of files called <code>nextFiles</code>. All files in <code>currentFiles</code> that are not in <code>nextFiles</code> should be deleted.</p><h3>Example</h3><p>Initial directory:</p><div class="highlight"><pre><span></span>testDir
--build.py
--main.c
</pre></div><p>Initial <code>build.py</code>:</p><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">shouldUpdate</span><span class="p">(</span><span class="s1">&#x27;main.c&#x27;</span><span class="p">,</span> <span class="s1">&#x27;main&#x27;</span><span class="p">):</span>
    <span class="n">bld</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#x27;gcc main.c -o main&#x27;</span><span class="p">)</span>
</pre></div><p>Directory after building:</p><div class="highlight"><pre><span></span>testDir
--build.py
--main.c
--main
--currentFiles
</pre></div><p>And current files is a simply the following text file:</p><div class="highlight"><pre><span></span>main
</pre></div><p>You then change <code>build.py</code> to the following:</p><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">shouldUpdate</span><span class="p">(</span><span class="s1">&#x27;main.c&#x27;</span><span class="p">,</span> <span class="s1">&#x27;main&#x27;</span><span class="p">):</span>
    <span class="n">bld</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#x27;gcc main.c -o myExecutable&#x27;</span><span class="p">)</span>
</pre></div><p>During the build, <code>currentFiles</code> is <code>[main]</code> and <code>nextFiles</code> is <code>[myExecutable]</code> which means bld deletes <code>main</code>.</p><p>Directory after building the second time:</p><div class="highlight"><pre><span></span>testDir
--build.py
--main.c
--myExecutable
--currentFiles
</pre></div><p>And currentFiles is now the following text file:</p><div class="highlight"><pre><span></span>myExecutable
</pre></div><p>A nice side effect of keeping a list of current files is that clean operations can be done automatically. Cleaning this directory means removing all non-essential files which removes all files in currentFiles and then removes currentFiles.</p><h2>What about directories?</h2><p>The one thing I overlooked in that example is directories. The easiest way to handle them is to keep track of all directories that had files removed from them. At the very end of the build process, the script checks those directories to see if any are empty and repeats the process until all directories have at least one thing in them. This is a similar approach to Github which doesn't support empty directories and instead focuses only on files which makes sense for projects because files are the only source of truth in a project. There is never a situation where project information is stored in a directory. As such, empty directories probably shouldn't exist.</p><p>But what is someone wants directories to exist? There may be a way to tell bld to keep track of directories and not delete some empty directories.</p><h2>Why it is challenging to use</h2><p>In a world where command-line-commands only write one file, this setup works really well. But consider the command <code>python</code> which runs a python file which can import any number of files. It suddenly becomes very challenging to track which files have been touched and which files need to be changed.</p><p>This leads to a compromise for writing efficient build systems with bld2:</p><ul><li>if the command is simple like copying a file, use <code>shouldUpdate</code>.</li><li>if the command is complex like using a python script to generate a website, run the calculation each time.</li></ul><p>In practice this works pretty well: This site takes 5s to build from scratch and 0.7s to re-build. The main time sync is converting a bunch of images from .png to .jpg which is easy to run only when necessary with <code>shouldUpdate</code>.</p></div></body></html>