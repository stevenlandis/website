<!doctype html><html><head><meta charset="UTF-8"><meta charset="UTF-8"><meta name="viewport" content="width=device-width" initial-scale="1.0"><link rel="icon" type="image" href="/favicon/16x16.png" sizes="16x16"><link rel="icon" type="image" href="/favicon/32x32.png" sizes="32x32"><link rel="icon" type="image" href="/favicon/96x96.png" sizes="96x96"><link rel="stylesheet" href="/css/styles.css"><link rel="stylesheet" href="/css/highlight.css"><title>Title</title></head><body><div class="title">Title</div><div class="main"><div class="navbar"><span><a href="/">Home</a></span><span><a style="margin-left:3em;" href="/resume">Resume</a></span><span><a style="margin-left:3em;" href="/posts/list">Posts</a></span><span><a style="margin-left:3em;" href="/fractal">Fractal Generator</a></span></div><h1><img src="/svg/logo.svg" class="h1-img">A Dependency Library</h1><h1><img src="/svg/logo.svg" class="h1-img">The Basics</h1><p>At the base, there are nodes that store a value. I can have a name and an age:</p><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="s1">&#x27;Carl&#x27;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">age</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</pre></div><p>I can't access these values directly, but there's a magic function called <code>open</code> that I can use to get the values.</p><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Object {...}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">name</span><span class="p">));</span> <span class="c1">// &#x27;Joe&#x27;</span>
</pre></div><p>I can also change the value of nodes.</p><div class="highlight"><pre><span></span><span class="nx">name</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#x27;Joe&#x27;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">name</span><span class="p">));</span> <span class="c1">// &#x27;Carl&#x27;</span>
</pre></div><p>The second thing I can make is a <code>fcn</code> which is a value computed from other nodes.</p><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">greeting</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="sb">`Hello, my name is </span><span class="si">${</span><span class="nx">open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="si">}</span><span class="sb"> and I am </span><span class="si">${</span><span class="nx">open</span><span class="p">(</span><span class="nx">age</span><span class="p">)</span><span class="si">}</span><span class="sb"> years old`</span><span class="p">);</span>
</pre></div><p>I can then open my greeting to get the value:</p><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">greeting</span><span class="p">));</span>
<span class="c1">// &#x27;Hello, my name is Joe and I am 1000 years old&#x27;</span>
</pre></div><p>But the magic really happens when I change one of the base values.</p><div class="highlight"><pre><span></span><span class="nx">age</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">29</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">greeting</span><span class="p">));</span>
<span class="c1">// &#x27;Hello, my name is Joe and I am 29 years old&#x27;</span>
</pre></div><p>There we go, that's more reasonable.</p><h1><img src="/svg/logo.svg" class="h1-img">Goodbye classes, hello functions</h1><p>A cool use of dependent variables is the ability to replace classes with functions and get some performance boosts.</p><p>Let's say I have a triangle formed by three points, and I want to get a bounding rectangle.</p><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Triangle</span><span class="p">(</span><span class="nx">pt0</span><span class="p">,</span> <span class="nx">pt1</span><span class="p">,</span> <span class="nx">pt2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">minX</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt1</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt2</span><span class="p">.</span><span class="nx">x</span><span class="p">)));</span>
  <span class="kr">const</span> <span class="nx">maxX</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt1</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt2</span><span class="p">.</span><span class="nx">x</span><span class="p">)));</span>
  <span class="kr">const</span> <span class="nx">minY</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt1</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt2</span><span class="p">.</span><span class="nx">y</span><span class="p">)));</span>
  <span class="kr">const</span> <span class="nx">maxY</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt1</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt2</span><span class="p">.</span><span class="nx">y</span><span class="p">)));</span>
  <span class="kr">const</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">open</span><span class="p">(</span><span class="nx">maxX</span><span class="p">)</span> <span class="o">-</span> <span class="nx">open</span><span class="p">(</span><span class="nx">minX</span><span class="p">));</span>
  <span class="kr">const</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">open</span><span class="p">(</span><span class="nx">maxY</span><span class="p">)</span> <span class="o">-</span> <span class="nx">open</span><span class="p">(</span><span class="nx">minY</span><span class="p">));</span>
  <span class="kr">const</span> <span class="nx">area</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// via cross product method</span>
    <span class="kr">const</span> <span class="nx">v0</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">x</span><span class="o">:</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt1</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">-</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span>
      <span class="nx">y</span><span class="o">:</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">-</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
    <span class="p">};</span>
    <span class="kr">const</span> <span class="nx">v1</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">x</span><span class="o">:</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt2</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">-</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span>
      <span class="nx">y</span><span class="o">:</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">-</span> <span class="nx">open</span><span class="p">(</span><span class="nx">pt0</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">v0</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">v0</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">minX</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">minY</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="nx">area</span><span class="p">};</span>
<span class="p">}</span>
</pre></div><p>So now I can use the triangle</p><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">pt0</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">node</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">node</span><span class="p">(</span><span class="mi">3</span><span class="p">)};</span>
<span class="kr">const</span> <span class="nx">pt1</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">node</span><span class="p">(</span><span class="mi">0</span><span class="p">)};</span>
<span class="kr">const</span> <span class="nx">pt2</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">node</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">node</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)};</span>
<span class="kr">const</span> <span class="nx">triangle</span> <span class="o">=</span> <span class="nx">Triangle</span><span class="p">(</span><span class="nx">pt0</span><span class="p">,</span> <span class="nx">pt1</span><span class="p">,</span> <span class="nx">pt2</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">width</span><span class="p">));</span> <span class="c1">// 4</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">height</span><span class="p">));</span> <span class="c1">// 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">area</span><span class="p">));</span> <span class="c1">// 13</span>
</pre></div><p>There are some nice benefits to using this approach over a class:</p><ol><li>Lazy computation: Values are only computed when they're needed. This means you can get the width of a triangle without the expensive area calculation.</li><li>Efficient value recalculation: Because the triangle's width doesn't depend on any of the point's y values, changing a y value won't force the width to be recalculated.</li><li>No <code>this</code>: Save your fingers by not typing <code>this</code> every time you want to access a value.</li></ol><h1><img src="/svg/logo.svg" class="h1-img">The reason you shouldn't use this everywhere</h1><p>While dependent variables are pretty cool, they're also really slow. Take the area example above. I compared calculating a triangle's area using a traditional approach and using the dependent variable and the traditional approach was about 2000x times slower. 2000x times. I haven't dug into why it runs so slowly, but I think it has to do with Javascript's garbage collector and the fact that dependent functions are closures with references to many variables. While they are convenient, they should be used carefully when making large applications.</p><h1><img src="/svg/logo.svg" class="h1-img">Another reason you shouldn't use this everywhere</h1><p>Dependent variables created this way need to keep track of where each variable is used. If a <code>node</code> is used in a <code>fcn</code>, the node needs to remember that fcn is one of it's users. So what happens when the fcn is no longer needed?</p><p>GARBAGE COLLECTION</p><p>Suddenly there is this idea of an event loop that manages updating value and state:</p><ol><li>Change a bunch of values and mark users as invalid</li><li>Read a bunch of values and re-calculate functions as needed</li><li>Maybe delete unused nodes</li></ol><p>But where this gets tricky is assuming that the dependency graph stays fixed as dependencies change. In most useful programs, <code>node</code> changes affect the dependency graph in strange ways. Let's look at the simplest example:</p><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">cond</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">open</span><span class="p">(</span><span class="nx">cond</span><span class="p">)</span> <span class="o">?</span> <span class="nx">open</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">:</span> <span class="nx">open</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">// 7</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">// 11</span>
<span class="nx">cond</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">// 5</span>
</pre></div><p>In this example, the dependency graph changes based on if <code>cond</code> is true or false. However, this also means that the value of <code>c</code> needs to be recalculated if <code>cond</code> changes.</p><p>Another example is for operating on an element in an array:</p><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span><span class="nx">node</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">node</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nx">node</span><span class="p">(</span><span class="mi">3</span><span class="p">)];</span>
<span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">open</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">open</span><span class="p">(</span><span class="nx">i</span><span class="p">)]));</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="c1">// 1</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="c1">// 3</span>
<span class="nx">list</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">set</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="c1">// 42</span>
</pre></div><p>This is pretty cool because it means that other elements in that list can change but <code>val</code> only depends on a single element. Taking this another step, array elements can be efficiently swapped and sorted by using an index array.</p><div class="highlight"><pre><span></span>
</pre></div><p>However, there's an issue: In javascript, garbage collection only works if references are removed, and if every node and fcn stores a list of all nodes that use itself, each node has a list of references that will challenge the garbage collector. The only solution is to somehow delete nodes.</p><p>The idea is simple: When a function node is first created, it doesn't know which variables it depends on and it's dependencies don't have a reference to the node. It's in a <code>new</code> state. When the function node runs for the first time, it adds itself to the list of dependers in each of its depencencies, creating a reference loop and a garbage collection nightmare.</p><p>But what if there was a way to reset the node back to its new state. I propose <code>node.reset()</code>, a method that deletes the cached current value and disconnects dependencies. The node then behaves like a brand new node. If you really need the value, you can always re-calculate it, but it probably won't be needed again.</p><p>So there appear to be two ways to think about deleting nodes: top-down and bottom-up</p><h3>Top-Down Deleting</h3><p>If I have a function node that is (probably) no longer needed, I can reset it which starts a chain reaction. Each node has a list of users, and if that list is empty, the node can probably be reset as well.</p><h3>Bottom-Up Deleting</h3><p>This one might not even be necessary but it's still interesting to think about. If I have a base node that is no longer needed and I want to mark it as deleted, that means all nodes that depend on the base node also need to be invalidated and recalculated because they might depend on a deleted node. Now that I think about it, probably not needed and we can do everything with top-down deleting :).</p><h1><img src="/svg/logo.svg" class="h1-img">Stateful Components</h1><p>Now I can begin to separate dependent logic out and create the base for stateful components.</p><p>Let's say I want to create a stateful component like a counter.</p><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Counter</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">countString</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">open</span><span class="p">(</span><span class="nx">count</span><span class="p">).</span><span class="nx">toString</span><span class="p">());</span>

  <span class="kr">const</span> <span class="nx">render</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Render</span><span class="p">();</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#x27;div&#x27;</span><span class="p">,</span> <span class="p">{},</span> <span class="sb">`</span><span class="si">${</span><span class="nx">open</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">open</span><span class="p">(</span><span class="nx">countString</span><span class="p">)</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#x27;button&#x27;</span><span class="p">,</span> <span class="p">{</span><span class="nx">onClick</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">count</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}},</span> <span class="s1">&#x27;Click Me!&#x27;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">render</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p>Clicking on the button increments the counter and everything works well. However, when I unmount the counter, it still has a reference to message which means JS's garbage collector won't forget <code>render</code> or <code>countString</code> or <code>count</code>. Uh oh.</p><p>We need a way to un-watch the render node returned by counter which means carefully resetting the render function after <code>Counter</code> unmounts. Not too bad.</p><h1><img src="/svg/logo.svg" class="h1-img">What about async?</h1><p>Async isn't too bad even though nodes are inherently sync.</p><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">resp</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="p">(</span><span class="nx">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">myWebRequest</span><span class="p">();</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
<span class="p">})();</span>

<span class="kr">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">prices</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">price</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">sum</span><span class="p">))</span> <span class="c1">// 0 b/c resp is initially null</span>

<span class="c1">// wait a while</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">sum</span><span class="p">))</span> <span class="c1">// 42 b/c the web request finished</span>
</pre></div><p>The main gotcha with async nodes is you need to have a base case for before the response has completed. While this may seem like a pain, and it does add complexity to projects, it makes it easy to visualize your app's state while loading and it updates very efficiently and lazily.</p><p>You can also do cool things like make a node that reads a file and updates when the file changes.</p><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">getFileReadNode</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">updateDelay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// begin as undefined</span>
  <span class="kd">let</span> <span class="nx">mTime</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">run</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">(</span><span class="nx">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">run</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">data</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">path</span><span class="p">)));</span>
      <span class="nx">await</span> <span class="nx">sleep</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">updateDelay</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}){}</span>
  <span class="nx">onReset</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">run</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// a better implementation using the file&#x27;s modify time</span>
<span class="kd">function</span> <span class="nx">getFileReadNode</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">updateDelay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// begin as undefined</span>
  <span class="kd">let</span> <span class="nx">mTime</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">run</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">onReset</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">run</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="p">(</span><span class="nx">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">run</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">newMTime</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">getMTime</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">path</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">newMTime</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">mTime</span> <span class="o">!==</span> <span class="nx">newMTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">path</span><span class="p">)));</span>
      <span class="p">}</span>
      <span class="nx">await</span> <span class="nx">sleep</span><span class="p">(</span><span class="nx">open</span><span class="p">(</span><span class="nx">updateDelay</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}){}</span>
  <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">fileData</span> <span class="o">=</span> <span class="nx">getFileReadNode</span><span class="p">(</span><span class="s1">&#x27;test.txt&#x27;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">fileSize</span> <span class="o">=</span> <span class="nx">fcn</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">open</span><span class="p">(</span><span class="nx">fileData</span><span class="p">)</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">open</span><span class="p">(</span><span class="nx">fileData</span><span class="p">).</span><span class="nx">length</span><span class="p">);</span>

<span class="c1">// or</span>
<span class="kr">const</span> <span class="nx">filePath</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="s1">&#x27;test.txt&#x27;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">delay</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">fileData</span> <span class="o">=</span> <span class="nx">getFileReadNode</span><span class="p">(</span><span class="nx">filePath</span><span class="p">,</span> <span class="nx">delay</span><span class="p">);</span>
</pre></div><p>This is really sweet because you can use the file's text throughout your application, but any variables that depend on it will be recalculated when the file changes.</p></div></body></html>